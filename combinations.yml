########################################################################
# RQG integration tests with DML and DDL, different engines.
# The default set is big bang, but it can be narrowed down through
# configuration parameters
########################################################################

trigger: none

# If we manage to run many more than 50 runs within less-than-6 hour limit,
# it probably means tests fail too quickly
parameters:
  - name : loops
    type : object
    default : [
      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
      11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
      21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
      31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
      41, 42, 43, 44, 45, 46, 47, 48, 49, 50
    ]

jobs:

#########
# Download or build server
- template: jobs/prepare-server.yml
  parameters:
    name: 'Download_or_Build_Server'

#########
# Upload to FTP
- template: jobs/upload-to-ftp.yml
  parameters:
    dependencies:
    - 'Download_or_Build_Server'
    condition: false
#    condition: and(succeeded(), ne(dependencies.Download_or_Build_Server.outputs['ftp_download.BINARIES_FROM_FTP'], 'true'))

#########
- job: Test
  timeoutInMinutes: 0
  dependsOn: Download_or_Build_Server
  pool:
    vmImage: 'Ubuntu 20.04'

  # Leave some room for reproducing
  strategy:
    parallel: 8

  steps:

  - template: steps/env.yml

  - task: DownloadBuildArtifacts@0
    inputs:
      artifactName: 'build'
      downloadPath: $(Build.ArtifactStagingDirectory)
    displayName: 'Download build from artifacts'

  - task: ExtractFiles@1
    inputs:
      archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/build/build-*.tar.gz'
      destinationFolder: $(env.BASEDIR)
    displayName: 'Extract build'

  - template: steps/install-deb-packages.yml
    parameters:
      INSTALLATION_SET: 'runtime'

  - template: steps/clone-test-tools.yml

  # If we get to more than 50 within the limit of 6 hours,
  # likely something is wrong anyway so that the tests are ending too quickly
  - ${{ each loop in parameters.loops }}:
    - script: |
        rm -rf $(Build.ArtifactStagingDirectory)/*
        if [ `date +'%s'` -lt $((ENV_END_TIME-600)) ] ; then
          TRIAL_NO=${{ loop }}
          echo "Trial $TRIAL_NO"
          echo "##vso[task.setvariable variable=TRIAL_NO;isOutput=true]$TRIAL_NO"
          rm -rf $ENV_LOGDIR
          mkdir -p $ENV_LOGDIR
          set -xo pipefail
          cd $ENV_RQG_HOME
          export ASAN_OPTIONS="abort_on_error=1,disable_coredump=0"
          perl ./combinations.pl \
            --basedir=$ENV_BASEDIR \
            --workdir=$ENV_LOGDIR \
            --config=$ENV_RQG_COMBINATIONS \
            --force \
            --discard-logs \
            --trials=1
          test_result=$?
          #
          set -x
          echo "#"
          echo "# Result collection"
          echo "#"
          #
          mv $ENV_LOGDIR/trial1.log $ENV_LOGDIR/trial.log
          mv $ENV_LOGDIR/current1_1 $ENV_LOGDIR/vardir
          #
          RUN_ID=$(System.JobPositionInPhase).$TRIAL_NO
          echo "##vso[task.setvariable variable=RUN_ID]$RUN_ID"
          summary_dir=$(Build.ArtifactStagingDirectory)/summary-$(Build.BuildNumber).$RUN_ID
          details_dir=$(Build.ArtifactStagingDirectory)/data-$(Build.BuildNumber).$RUN_ID
          repro_dir=$(Build.ArtifactStagingDirectory)/repro-$(Build.BuildNumber).$RUN_ID
          mkdir -p $summary_dir $details_dir $repro_dir
          cp $ENV_LOGDIR/trial.log $ENV_RQG_HOME/rqg.info $ENV_BASEDIR/server.info $ENV_TOOLBOX_DIR/toolbox.info $summary_dir/
          cp --parents `find $ENV_LOGDIR -name mysql*err* | xargs` $summary_dir/
          cp --parents `find $ENV_LOGDIR -name mbackup*log* | xargs` $summary_dir/
          if [ -e $ENV_LOGDIR/vardir/mysql.log ] ; then
            gzip $ENV_LOGDIR/vardir/mysql.log
            mv $ENV_LOGDIR/vardir/mysql.log.gz $repro_dir/
          fi
          for c in `find $ENV_LOGDIR -name core*` ; do
            echo "#################### $c ####################" >> $summary_dir/stacktraces
            echo "#################### $c ####################" >> $details_dir/threads
            echo "#################### $c ####################" >> $details_dir/threads_full
            binary=`gdb --batch --eval-command="bt" 1 $c 2>&1 | grep -a 'Core was generated by' | sed -e 's/^Core was generated by \`\([^ ]*\) .*/\1/'`
            echo $binary >> $summary_dir/stacktraces
            echo $binary >> $details_dir/threads
            echo $binary >> $details_dir/threads_full
            gdb --batch --eval-command="bt" $binary $c  | grep -a -v 'New LWP' >> $summary_dir/stacktraces
            gdb --batch --eval-command="thread apply all bt" $binary $c >> $details_dir/threads
            gdb --batch --eval-command="thread apply all bt full" $binary $c >> $details_dir/threads_full
          done
          if [ -e $ENV_LOGDIR/trial.log ] ; then
            result_collection_options="--test-log=$ENV_LOGDIR/trial.log"
          fi
          for d in $ENV_LOGDIR/vardir* ; do
            result_collection_options="$result_collection_options --vardir=$d"
          done
          echo "" >> $summary_dir/test_report
          echo "Test $RUN_ID" >> $summary_dir/test_report
          # First choice: runall prints the status right before exit
          res=`grep -a 'runall.* will exit with exit status' $summary_dir/trial.log | sed -e 's/.*will exit with exit status STATUS_\([A-Z_]*\).*/\1/'`
          # Second choice: runall prints the status of GenTest after GenTest exited. It doesn't include final checks
          if [ -z "$res" ] ; then
            res=`grep -a 'GenTest exited with exit status' $summary_dir/trial.log | sed -e 's/.*exited with exit status STATUS_\([A-Z_]*\).*/\1/'`
          fi
          # Last choice: GenTest prints the status before exiting
          if [ -z "$res" ] ; then
            res=`grep -a 'GenTest will exit with exit status' $summary_dir/trial.log | sed -e 's/.*will exit with exit status STATUS_\([A-Z_]*\).*/\1/'`
          fi
          echo "Test result:" $res >> $summary_dir/test_report
          export TEST_RESULT=$res
          echo "Trigger ID:" $(System.DefinitionId)-$(Build.BuildId)-$(Build.BuildNumber).$RUN_ID >> $summary_dir/test_report
          echo "-------------------------------------" >> $summary_dir/test_report
          echo "" >> $summary_dir/test_report
          cp $summary_dir/server.info $repro_dir/repro.info
          rqg_cmd=`grep -a -A 1 'Final command line' $summary_dir/trial.log | tail -n 1`
          mysqld_options=""
          for o in $rqg_cmd ; do
            if expr match "$o" "--mysqld" > /dev/null ; then
              mysqld_options="$mysqld_options $o"
            fi
          done
          echo "" >> $repro_dir/repro.info
          echo "RQG command line: $rqg_cmd" >> $repro_dir/repro.info
          echo "MySQLd options: $mysqld_options" >> $repro_dir/repro.info
          echo `cat $summary_dir/rqg.info` `cat $summary_dir/toolbox.info` >> $summary_dir/test_report
          cat $repro_dir/repro.info >> $summary_dir/test_report
          export TEST_ID=$(Build.BuildId).$RUN_ID
          echo >> $summary_dir/test_report
          $ENV_TOOLBOX_DIR/scripts/collect_rqg_result_info.sh $result_collection_options > $summary_dir/result_info
          echo "----" >> $summary_dir/result_info
          export SERVER_REVNO=`head -1 $summary_dir/server.info | awk '{print $2}'`
          echo "----" >> $summary_dir/result_info
          echo "Trigger ID:" $(System.DefinitionId)-$(Build.BuildId)-$(Build.BuildNumber).$RUN_ID >> $summary_dir/result_info
          perl $ENV_RQG_HOME/util/check_for_known_bugs.pl --signatures=$ENV_RQG_HOME/data/bug_signatures $summary_dir/result_info >> $summary_dir/result_info
          match_search_result=$?
          echo >> $summary_dir/test_report
          echo "#####################################" >> $summary_dir/test_report
          cat $summary_dir/result_info >> $summary_dir/test_report
          echo "#####################################" >> $summary_dir/test_report
          cat $summary_dir/test_report
          #
          if [ "$test_result" != "0" ] ; then
            if [ "$match_search_result" != "0" ] ; then
              echo "##vso[task.complete result=Failed]Failure without matches"
              tar zcf $details_dir/logs.tar.gz $ENV_LOGDIR
            else
              echo "##vso[task.complete result=SucceededWithIssues]Failure with matches"
            fi
          else
            echo "##vso[task.complete result=Succeeded]Pass"
          fi
        else
          echo "Skipping the test, too little time left"
          echo "##vso[task.complete result=Skipped]Too little time left"
        fi
      displayName: Combination ${{ loop }}
      condition: always()
      env:
        DB_HOST: $(DbHost)
        DB_PORT: $(DbPort)
        DB_USER: $(DbUser)
        DBP: $(DbPwd)

    - task: PublishBuildArtifacts@1
      inputs:
        pathtoPublish: $(Build.ArtifactStagingDirectory)
        artifactName: test-$(Build.BuildNumber).$(System.JobPositionInPhase).${{ loop }}
      displayName: Store test result
      condition: not(succeeded())
      continueOnError: true
